slti $t2, $t1, 2指令执行过程：

a. 取指令（Instruction Fetch）：

从指令存储器中读取指令slti $t2, $t1, 2。
PC（程序计数器）增加指令的大小，以指向下一条指令的地址。
b. 指令译码（Instruction Decode）：

解码指令，确定操作数和操作码。
读取寄存器文件，获取$t1的值（源操作数1）。
c. 执行（Execute）：

将$t1的值与立即数2进行比较。
如果$t1小于2，则将$t2设置为1；否则将$t2设置为0。
生成结果并将其存储在临时寄存器中。
d. 写回（Write Back）：

将结果（1或0）写回到$t2寄存器。
beqz $t2, done指令执行过程：

a. 取指令（Instruction Fetch）：

从指令存储器中读取指令beqz $t2, done。
PC（程序计数器）增加指令的大小，以指向下一条指令的地址。
b. 指令译码（Instruction Decode）：

解码指令，确定操作数和操作码。
读取寄存器文件，获取$t2的值（源操作数1）。
c. 执行（Execute）：

检查$t2的值是否为零。
如果$t2等于零，则跳转到标记为"done"的地址。



取指令（Instruction Fetch）：

从指令存储器中读取指令addi $t0, $t0, 4。
PC（程序计数器）增加指令的大小，以指向下一条指令的地址。
指令译码（Instruction Decode）：

解码指令，确定操作数和操作码。
读取寄存器文件，获取$t0的值（源操作数1）。
执行（Execute）：

将$t0的值与立即数4相加。
生成结果并将其存储在临时寄存器中。
写回（Write Back）：

将结果写回到$t0寄存器。


lui $at, 0x0000指令执行过程：

a. 取指令（Instruction Fetch）：

从指令存储器中读取指令lui $at, 0x0000。
PC（程序计数器）增加指令的大小，以指向下一条指令的地址。
b. 指令译码（Instruction Decode）：

解码指令，确定操作数和操作码。
将立即数0x0000扩展为32位。
c. 执行（Execute）：

将扩展后的立即数左移16位（LUI操作）。
生成结果并将其存储在临时寄存器$at中。
d. 写回（Write Back）：

将结果写回到寄存器$at。
ori $t0, $at, 0xE2C3指令执行过程：

a. 取指令（Instruction Fetch）：

从指令存储器中读取指令ori $t0, $at, 0xE2C3。
PC（程序计数器）增加指令的大小，以指向下一条指令的地址。
b. 指令译码（Instruction Decode）：

解码指令，确定操作数和操作码。
读取寄存器文件，获取$at的值（源操作数1）。
将立即数0xE2C3扩展为32位。
c. 执行（Execute）：

将$at的值与扩展后的立即数进行按位或操作（ORI操作）。
生成结果并将其存储在临时寄存器$t0中。
d. 写回（Write Back）：

将结果写回到寄存器$t0。
sw $s0, 0($t0)指令执行过程：

a. 取指令（Instruction Fetch）：

从指令存储器中读取指令sw $s0, 0($t0)。
PC（程序计数器）增加指令的大小，以指向下一条指令的地址。
b. 指令译码（Instruction Decode）：

解码指令，确定操作数和操作码。
读取寄存器文件，获取$s0和$t0的值（源操作数1和源操作数2）。
c. 执行（Execute）：

将$s0的值存储到$t0寄存器中偏移量为0的存储器位置。
d. 写回（Write Back）：

无写回操作。