# 实验报告：语义分析器的设计与实现
*王贤义*

*计算机基地班*

*320210931221*

## 实验目的

**理解语义分析器的设计与实现：** 掌握语义分析器的设计和实现原理。$$

**理解类型检查的分析和实现：** 

## 语法规则

```
PROG     -> {    DECLS    STMTS    }
DECLS    -> DECLS DECL | $
DECL     -> int  NAMES  ;  |  bool  NAMES  ; 
NAMES    -> NAMES ,  NAME  |  NAME
NAME     -> id
STMTS    -> STMTS  STMT  |   STMT          
STMT     -> id  =  EXPR ;    |   id := BOOL ;
STMT     -> if  id   then  STMT
STMT     -> if  id   then  STMT  else STMT
STMT     -> while   id  do  STMT
STMT     -> {  STMTS   STMT  }
STMT     -> read  id  ;
STMT     -> write  id  ;
EXPR     -> EXPR  ADD  TERM  |  TERM
ADD      -> + | -
TERM     -> TERM  MUL NEGA  |  NEGA
MUL      -> * | /
NEGA     -> FACTOR  |  - FACTOR  
FACTOR   -> (  EXPR ) |  id  |  number 
BOOL     -> BOOL  ||  JOIN    |    JOIN
JOIN     -> JOIN   &&   NOT  |   NOT
NOT      -> REL   |  ! REL
REL      -> EXPR   ROP  EXPR 
ROP      -> >  |  >=  |  <  |  <=  |  ==  |   !=
```

通过分析显然此语法存在不可避免的移进规约冲突（if else），本语法不属于SLR语法，但通过强制规定else与最近的if连接，当if  id   then  STMT • 遇见else时，强制移进>规约。

## 设计约束

（1）从技术路线上说，语义分析应遵循语法制导翻译方法，在语法分析的基础之上进行。

（2）从处理过程上来说，整个分析过程对源程序处理两遍或三遍。例如，第一遍是词法分析和语法分析，以语法分析为主导，工作成果是语法错误报告或语法树；第二遍是类型检查和代码翻译，工作成果是类型错误报告或中间代码。在第一遍工作中报告错误后就退出分析，不再进入第二遍处理。第二遍类似，只有在没有任何错误的情况下才进入代码翻译工作。也可以把类型检查做成第二遍，把代码翻译做成第三遍。

（3）从程序结构上来说，语义分析要调用前面词法和语法分析的程序。所以建议将该程序设计为多个模块，至少要明确区分出驱动模块和工作模块。驱动模块包含了程序的入口和出口，主要负责输入、输出处理并按照设定的工作逻辑调用各个工作模块来完成工作；工作模块可以是：词法分析器、语法分析器、语义分析器的分解或组合，还可以专门设计一些子模块来完成特定工作，如：遍历树、查填符号表、报告错误等。

（4）从数据结构上说，语法树和符号表都是非常重要的全局数据结构，应该做好相应的设计。

## 程序设计与实现

### 工作流程

1. **移进**：移进过程中将文法符号信息压入
2. **规约**：规约过程中执行类型检查和代码翻译

### 关键算法描述

移进

![](\pic\移进1.png)

规约

![](D:\code\CPE\3\pic\规约1.png)

- 语义分析的关键代码在ExecuteSemanticCheck()中，包含类型检查和代码翻译

```python
if __name__ == "__main__": 
    file_name ="./sourceProgram/sourceProgram2.txt"
    sa = SyntacticAnalyzer()
    if sa.StartAnalize(file_name):
        sa.VisualizeTree(
            sa.tree_node_stack_[0],
            "./treeOutput/treeOutput2.txt"
        )

```

- 识别语法，分别为从txt中生成文法产生式、生成拓广文法，生成非终结符First集、Follow集、生成文法符号集、生成LR项目和生成项目集规范族。

```python
    def build_grammar(self):
        self.GenProduction()
        self.GenAugmentedGrammar()
        self.GenFirstSet()
        self.GenFollowSet()
        self.GenGrammarSymbolSet()
        self.GenLrItems()
        return self.GenNormalFamilySet()
```

- 递归下降语法分析中循环从词法分析器中读入一个词，并根据上一步中生成的action_goto表决定移进、规约和报错等

```python
while True:
            get_word = lexcial_analyzer.GetWord()
            word_string = get_word.word_string
            if get_word.type == LEXICAL_TYPE.LUNKNOWN:  # 错误处理
                print("词法分析器过程中，发生unknown错误！")
                print(get_word.value)
            while True:
                current_state = self.state_sequence_stack_[-1]  # 选择状态序列栈栈顶

                if (
                    current_state,
                    word_string,
                ) not in self.action_goto_tables_:  # action_goto表中不存在对应的操作，语法分析过程中出现错误，报告错误并返回
                    print("语法分析器过程中，发生错误！")
                    print(get_word.value)

                    print(
                        "state：",
                        current_state,
                        " 与 ",
                        word_string,
                        " 在action_goto_table 中不含对应操作!",
                    )
                    return False

                if (
                    self.action_goto_tables_[(current_state, word_string)].op
                    == SLR_OPERATIONS.MOVE
                ):  # 移进操作
                    self.state_sequence_stack_.append(
                        self.action_goto_tables_[(current_state, word_string)].state
                    )
                    self.move_conclude_string_stack_.append(word_string)
                    self.PrintAnalysisProcess(
                        sytactic_step,
                        self.action_goto_tables_[(current_state, word_string)],
                        get_word
                    )
                    sytactic_step += 1
                    self.grammar_symbol_info_stack_.append(
                        {get_word.word_string, get_word.value}
                    )  # 文法符号信息压入
                    break

                elif (
                    self.action_goto_tables_[(current_state, word_string)].op
                    == SLR_OPERATIONS.CONCLUDE
                ):  # 规约操作
                    conclude_production_number = self.action_goto_tables_[
                        (current_state, word_string)
                    ].state
                    if self.productions_[conclude_production_number].right[0] == "$":
                        production_length = 0
                    else:
                        production_length = len(
                            self.productions_[conclude_production_number].right
                        )

                    for i in range(
                        production_length
                    ):  # 将两个栈都弹出production_length个元素
                        self.state_sequence_stack_.pop()
                        self.move_conclude_string_stack_.pop()

                    self.move_conclude_string_stack_.append(
                        self.productions_[conclude_production_number].left
                    )  # 用于规约的产生式的左部 压入栈中
                    if (
                        self.state_sequence_stack_[-1],
                        self.productions_[conclude_production_number].left,
                    ) not in self.action_goto_tables_:  # 不存在goto
                        print("语法分析器算法发生致命错误CONCLUDE中")
                        print(get_word.value)
                        return False

                    self.state_sequence_stack_.append(
                        self.action_goto_tables_[
                            (
                                self.state_sequence_stack_[-1],
                                self.productions_[conclude_production_number].left,
                            )
                        ].state
                    )  # goto对应的状态压入

                elif (
                    self.action_goto_tables_[(current_state, word_string)].op
                    == SLR_OPERATIONS.ACCEPT
                ):  # 宣布接受
                    self.PrintAnalysisProcess(
                        sytactic_step,
                        self.action_goto_tables_[(current_state, word_string)],
                        get_word
                    )
                    sytactic_step += 1

                    print("语法分析正确完成！")
                    return True

                else:  # 语法分析器算法错误
                    print("致命错误！")
                    print("语法分析器算法存在错误，请检查！")
                    return False

                self.PrintAnalysisProcess(
                    sytactic_step,
                    self.action_goto_tables_[(current_state, word_string)],
                    get_word
                )
                sytactic_step += 1

        return True
```

- 生成完整语法树结点并连接，位于PrintAnalysisProcess函数中，移进时生成一个结点放入临时栈中，规约时从栈中取出若干结点作为子节点，生成规约项目的父节点并连接。

```python
# 输出操作
        if sl_op.op == SLR_OPERATIONS.MOVE:
            self.syntactic_analyzer_printer_.write("移进")
            if self.move_conclude_string_stack_[-1]=="id" or self.move_conclude_string_stack_[-1]=="number":
                self.tree_node_stack_.append(TreeNode(get_word.value))
            else:
                self.tree_node_stack_.append(TreeNode(self.move_conclude_string_stack_[-1]))
        elif sl_op.op == SLR_OPERATIONS.ACCEPT:
            self.syntactic_analyzer_printer_.write("接受")
        elif sl_op.op == SLR_OPERATIONS.CONCLUDE:
            if self.productions_[sl_op.state].right[0] == "$":
                self.tree_node_stack_.append(TreeNode("$"))
            conclude_tree_node_ = TreeNode(self.productions_[sl_op.state].left)
            conclude_tree_node_.child = self.tree_node_stack_[
                -len(self.productions_[sl_op.state].right) :
            ]
            self.tree_node_stack_ = self.tree_node_stack_[
                : -len(self.productions_[sl_op.state].right)
            ]
            self.tree_node_stack_.append(conclude_tree_node_)
            self.syntactic_analyzer_printer_.write(
                "规约： " + self.productions_[sl_op.state].left + "->"
            )
            for symbol in self.productions_[sl_op.state].right:
                if symbol == ",":
                    self.syntactic_analyzer_printer_.write("，")
                else:
                    self.syntactic_analyzer_printer_.write(symbol + " ")
```

### 数据结构设计

- **SLR_OPERATIONS**：枚举，用于存储移进，规约和接受等操作类型。
- **TreeNode**：类，用于存储树结点的值和孩子结点。
- **LrItem**：类，存储LR项目，包括涉及的产生式和其中•的位置信息。
- **first_map_, follow_map_**：字典，用于存储非终结符的first集和follow集。
- **state_sequence_stack_**：列表，状态栈。
- **move_conclude_string_stack_**：列表，符号栈。
- **tree_node_stack_**：列表，树结点栈。
- **normal_family_**：列表，项目集规范族。
- **action_goto_tables_**：集合，存储（状态，符号）对应的操作。
### 程序结构

```python
class SLR_OPERATIONS(Enum): ...
class TreeNode: ...
class LrItem: ... 
class SlrOperation: ... 

class SyntacticAnalyzer: 
    def __init__(self, show_detail=True):
    def IsNonTerminalSymbol(self, symbol):
	def GetProductionFirstSet(self, symbol_string):
	def GenProduction(self):
    def GenAugmentedGrammar(self):
    def GenFirstSet(self):
    def GenFollowSet(self):
    def GenGrammarSymbolSet(self):
    def GenLrItems(self):
    def GenItemClosureSet(self, input_item):
    def GenItemsClosureSet(self, items):
    def GenNormalFamilySet(self):
    def build_grammar(self):
    def PrintAnalysisProcess(self, step, sl_op ,get_word):
    def StartAnalize(self, code_filename):
    ...
if __name__ == "__main__": 
    file_name ="./sourceProgram/sourceProgram.txt"
    sa = SyntacticAnalyzer()
    if sa.StartAnalize(file_name):
        sa.VisualizeTree(
            sa.tree_node_stack_[0],
            "./treeOutput/treeOutput.txt"
        )

```

### 测试用例及结果

​		程序经过6组测试用例进行了充分测试，测试结果显示当程序符合语法规则时会输出完整的竖向语法分析树，当程序不符合语法规则时会抛出导致报错的位置和对应单词。

##### 测试1

输入 sourceProgram1.txt：

![image-20240308103822020](pic\s1.png)

输出 treeOutput1.txt：

![image-20240308103749066](pic\t1.png)

##### 测试2

输入 sourceProgram2.txt:

![image-20240308103940674](pic\s2.png)

输出 treeOutput2.txt：

![image-20240308104117195](pic\t2.png)

##### 测试3

输入 sourceProgram3.txt:

![image-20240308105944107](pic\s3.png)

输出 treeOutput3.txt：

![image-20240308105916954](pic\t3.png)

##### 测试4

输入 sourceProgram4.txt:

![image-20240308110231044](pic\s4.png)

输出 treeOutput4.txt：

![image-20240308110339984](pic\t4.png)

##### 测试5

错误测试，空程序不符合语法规则，语法分析器会抛出报错单词。

输入 sourceProgram9.txt:

![image-20240308111801405](pic\s9.png)

输出报错：

![image-20240308111816580](pic\e9.png)

##### 测试6

错误测试，根据语法规则有"&&"的左右两边都必须接表达式非单独的id，例如本例中第九行的flag。

输入 sourceProgram10.txt:

![image-20240326165427326](pic\s10.png)

输出报错：

![image-20240326170312230](pic\e10.png)